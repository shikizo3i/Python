<!doctype html>
<html lang="en">

<head>
    <title>Learn Python Programming Language</title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="description" content="None">



    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="assets/css/bootstrap.min.css">
    <link rel="stylesheet" href="assets/css/dracula-ui.css">
    <link rel="stylesheet" href="assets/css/mkdocs.css">


    <link rel="icon" type="image/x-icon" href="assets/img/favicon.ico">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

</head>

<body class="drac-bg-black-secondary drac-text-grey-ternary drac-text drac-scrollbar-purple">

    <main class="d-flex">

        <!-- block sidebar -->
        <nav id="sidebar" class="sidebar drac-bg-black">
            <div class="custom-menu">
                <button type="button" id="sidebarCollapse" class="btn btn-primary">
                    <i class="fa fa-bars"></i>
                    <span class="sr-only">Menu</span>
                </button>
            </div>

            <div class="p-4">


                <div class="drac-text-center">

                    <span class="drac-text drac-line-height drac-text-white">Learn Python Programming Language</span>

                </div>

                <div class="drac-box flex-column">
                    <ul class="dot-ul">
                        <li>
                            <div class="dot-li drac-bg-cyan"></div>
                        </li>
                        <li>
                            <div class="dot-li drac-bg-green"></div>
                        </li>
                        <li>
                            <div class="dot-li drac-bg-orange"></div>
                        </li>
                        <li>
                            <div class="dot-li drac-bg-pink"></div>
                        </li>
                        <li>
                            <div class="dot-li drac-bg-purple"></div>
                        </li>
                        <li>
                            <div class="dot-li drac-bg-red"></div>
                        </li>
                        <li>
                            <div class="dot-li drac-bg-yellow"></div>
                        </li>
                    </ul>
                </div>

                <hr class="drac-divider" />

                <!-- block menu -->
                <ul class="mb-5 drac-list drac-list-none">

                </ul>
                <!-- endblock -->
            </div>
        </nav>
        <!-- endblock -->

        <nav class="divider drac-bg-purple-cyan"></nav>

        <div class="content">
            <!-- block header -->
            <header>
                <nav class="navbar navbar-expand-xl drac-bg-purple"">
        <div class=" container-fluid">

                    <!-- <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarsMenu"
                aria-controls="navbarsMenu" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button> -->

                    <div class="collapse navbar-collapse flex-column ml-auto" id="navbarsMenu">
                        <ul class="navbar-nav">

                            <!-- block preview -->
                            <li class="nav-item">

                            </li>
                            <!--  endblock -->

                            <!-- block search -->
                            <li class="nav-item">
                                <div role="search" class="search-box">
                                    <form id="rtd-search-form" class="wy-form" action="./search.html" method="get">
                                        <input type="text" name="q"
                                            class="drac-input drac-input-search drac-input-white drac-text-white drac-bg-black-secondary"
                                            placeholder="Search docs" title="Type search term here" />
                                    </form>
                                </div>
                            </li>
                            <!--  endblock -->

                            <!-- block source -->
                            <li class="nav-item">

                            </li>
                            <!--  endblock -->

                        </ul>
                    </div>

        </div>
        </nav>
        </header>
        <!-- endblock -->

        <!-- block content -->
        <section class="p-md-5 section-content">
            <article>
                <p>
                <h1 id="condensed-documentation">Condensed Documentation</h1>
                <p>Condensed python documentation on how to use python programming language.</p>
                <!-- linenums="1" title="learn_python_mini_documentation.py" hl_lines="1032-1058" -->

                <pre><code class="language-python">

# Single line comments start with a number symbol.

&quot;&quot;&quot; Multiline strings can be written
    using three &quot;s, and are often used
    as documentation.
&quot;&quot;&quot;

####################################################
## 1. Primitive Datatypes and Operators
####################################################

# You have numbers
3  # =&gt; 3

# Math is what you would expect
1 + 1   # =&gt; 2
8 - 1   # =&gt; 7
10 * 2  # =&gt; 20
35 / 5  # =&gt; 7.0

# Integer division rounds down for both positive and negative numbers.
5 // 3       # =&gt; 1
-5 // 3      # =&gt; -2
5.0 // 3.0   # =&gt; 1.0 # works on floats too
-5.0 // 3.0  # =&gt; -2.0

# The result of division is always a float
10.0 / 3  # =&gt; 3.3333333333333335

# Modulo operation
7 % 3   # =&gt; 1
# i % j have the same sign as j, unlike C
-7 % 3  # =&gt; 2

# Exponentiation (x**y, x to the yth power)
2**3  # =&gt; 8

# Enforce precedence with parentheses
1 + 3 * 2    # =&gt; 7
(1 + 3) * 2  # =&gt; 8

# Boolean values are primitives (Note: the capitalization)
True   # =&gt; True
False  # =&gt; False

# negate with not
not True   # =&gt; False
not False  # =&gt; True

# Boolean Operators
# Note &quot;and&quot; and &quot;or&quot; are case-sensitive
True and False  # =&gt; False
False or True   # =&gt; True

# True and False are actually 1 and 0 but with different keywords
True + True # =&gt; 2
True * 8    # =&gt; 8
False - 5   # =&gt; -5

# Comparison operators look at the numerical value of True and False
0 == False  # =&gt; True
2 &gt; True    # =&gt; True
2 == True   # =&gt; False
-5 != False # =&gt; True

# None, 0, and empty strings/lists/dicts/tuples/sets all evaluate to False.
# All other values are True
bool(0)     # =&gt; False
bool(&quot;&quot;)    # =&gt; False
bool([])    # =&gt; False
bool({})    # =&gt; False
bool(())    # =&gt; False
bool(set()) # =&gt; False
bool(4)     # =&gt; True
bool(-6)    # =&gt; True

# Using boolean logical operators on ints casts them to booleans for evaluation,
# but their non-cast value is returned. Don't mix up with bool(ints) and bitwise
# and/or (&amp;,|)
bool(0)     # =&gt; False
bool(2)     # =&gt; True
0 and 2     # =&gt; 0
bool(-5)    # =&gt; True
bool(2)     # =&gt; True
-5 or 0     # =&gt; -5

# Equality is ==
1 == 1  # =&gt; True
2 == 1  # =&gt; False

# Inequality is !=
1 != 1  # =&gt; False
2 != 1  # =&gt; True

# More comparisons
1 &lt; 10  # =&gt; True
1 &gt; 10  # =&gt; False
2 &lt;= 2  # =&gt; True
2 &gt;= 2  # =&gt; True

# Seeing whether a value is in a range
1 &lt; 2 and 2 &lt; 3  # =&gt; True
2 &lt; 3 and 3 &lt; 2  # =&gt; False
# Chaining makes this look nicer
1 &lt; 2 &lt; 3  # =&gt; True
2 &lt; 3 &lt; 2  # =&gt; False

# (is vs. ==) is checks if two variables refer to the same object, but == checks
# if the objects pointed to have the same values.
a = [1, 2, 3, 4]  # Point a at a new list, [1, 2, 3, 4]
b = a             # Point b at what a is pointing to
b is a            # =&gt; True, a and b refer to the same object
b == a            # =&gt; True, a's and b's objects are equal
b = [1, 2, 3, 4]  # Point b at a new list, [1, 2, 3, 4]
b is a            # =&gt; False, a and b do not refer to the same object
b == a            # =&gt; True, a's and b's objects are equal

# Strings are created with &quot; or '
&quot;This is a string.&quot;
'This is also a string.'

# Strings can be added too
&quot;Hello &quot; + &quot;world!&quot;  # =&gt; &quot;Hello world!&quot;
# String literals (but not variables) can be concatenated without using '+'
&quot;Hello &quot; &quot;world!&quot;    # =&gt; &quot;Hello world!&quot;

# A string can be treated like a list of characters
&quot;Hello world!&quot;[0]  # =&gt; 'H'

# You can find the length of a string
len(&quot;This is a string&quot;)  # =&gt; 16

# Since Python 3.6, you can use f-strings or formatted string literals.
name = &quot;Pallavi&quot;
f&quot;She said her name is {name}.&quot; # =&gt; &quot;She said her name is Pallavi.&quot;
# Any valid Python expression inside these braces is returned to the string.
f&quot;{name} is {len(name)} characters long.&quot; # =&gt; &quot;Nitkarsh is 8 characters long.&quot;

# None is an object
None  # =&gt; None

# Don't use the equality &quot;==&quot; symbol to compare objects to None
# Use &quot;is&quot; instead. This checks for equality of object identity.
&quot;etc&quot; is None  # =&gt; False
None is None   # =&gt; True

####################################################
## 2. Variables and Collections
####################################################

# Python has a print function
print(&quot;I'm Nitkarsh. Nice to meet you!&quot;)  # =&gt; I'm Nitkarsh. Nice to meet you!

# By default the print function also prints out a newline at the end.
# Use the optional argument end to change the end string.
print(&quot;Hello, World&quot;, end=&quot;!&quot;)  # =&gt; Hello, World!

# Simple way to get input data from console
input_string_var = input(&quot;Enter some data: &quot;) # Returns the data as a string

# There are no declarations, only assignments.
# Convention is to use lower_case_with_underscores
some_var = 5
some_var  # =&gt; 5

# Accessing a previously unassigned variable is an exception.
# See Control Flow to learn more about exception handling.
some_unknown_var  # Raises a NameError

# if can be used as an expression
# Equivalent of C's '?:' ternary operator
&quot;yay!&quot; if 0 &gt; 1 else &quot;nay!&quot;  # =&gt; &quot;nay!&quot;

# Lists store sequences
li = []
# You can start with a prefilled list
other_li = [4, 5, 6]

# Add stuff to the end of a list with append
li.append(1)    # li is now [1]
li.append(2)    # li is now [1, 2]
li.append(4)    # li is now [1, 2, 4]
li.append(3)    # li is now [1, 2, 4, 3]
# Remove from the end with pop
li.pop()        # =&gt; 3 and li is now [1, 2, 4]
# Let's put it back
li.append(3)    # li is now [1, 2, 4, 3] again.

# Access a list like you would any array
li[0]   # =&gt; 1
# Look at the last element
li[-1]  # =&gt; 3

# Looking out of bounds is an IndexError
li[4]  # Raises an IndexError

# You can look at ranges with slice syntax.
# The start index is included, the end index is not
# (It's a closed/open range for you mathy types.)
li[1:3]   # Return list from index 1 to 3 =&gt; [2, 4]
li[2:]    # Return list starting from index 2 =&gt; [4, 3]
li[:3]    # Return list from beginning until index 3  =&gt; [1, 2, 4]
li[::2]   # Return list selecting every second entry =&gt; [1, 4]
li[::-1]  # Return list in reverse order =&gt; [3, 4, 2, 1]
# Use any combination of these to make advanced slices
# li[start:end:step]

# Make a one layer deep copy using slices
li2 = li[:]  # =&gt; li2 = [1, 2, 4, 3] but (li2 is li) will result in false.

# Remove arbitrary elements from a list with &quot;del&quot;
del li[2]  # li is now [1, 2, 3]

# Remove first occurrence of a value
li.remove(2)  # li is now [1, 3]
li.remove(2)  # Raises a ValueError as 2 is not in the list

# Insert an element at a specific index
li.insert(1, 2)  # li is now [1, 2, 3] again

# Get the index of the first item found matching the argument
li.index(2)  # =&gt; 1
li.index(4)  # Raises a ValueError as 4 is not in the list

# You can add lists
# Note: values for li and for other_li are not modified.
li + other_li  # =&gt; [1, 2, 3, 4, 5, 6]

# Concatenate lists with &quot;extend()&quot;
li.extend(other_li)  # Now li is [1, 2, 3, 4, 5, 6]

# Check for existence in a list with &quot;in&quot;
1 in li  # =&gt; True

# Examine the length with &quot;len()&quot;
len(li)  # =&gt; 6


# Tuples are like lists but are immutable.
tup = (1, 2, 3)
tup[0]      # =&gt; 1
tup[0] = 3  # Raises a TypeError

# Note that a tuple of length one has to have a comma after the last element but
# tuples of other lengths, even zero, do not.
type((1))   # =&gt; &lt;class 'int'&gt;
type((1,))  # =&gt; &lt;class 'tuple'&gt;
type(())    # =&gt; &lt;class 'tuple'&gt;

# You can do most of the list operations on tuples too
len(tup)         # =&gt; 3
tup + (4, 5, 6)  # =&gt; (1, 2, 3, 4, 5, 6)
tup[:2]          # =&gt; (1, 2)
2 in tup         # =&gt; True

# You can unpack tuples (or lists) into variables
a, b, c = (1, 2, 3)  # a is now 1, b is now 2 and c is now 3
# You can also do extended unpacking
a, *b, c = (1, 2, 3, 4)  # a is now 1, b is now [2, 3] and c is now 4
# Tuples are created by default if you leave out the parentheses
d, e, f = 4, 5, 6  # tuple 4, 5, 6 is unpacked into variables d, e and f
# respectively such that d = 4, e = 5 and f = 6
# Now look how easy it is to swap two values
e, d = d, e  # d is now 5 and e is now 4


# Dictionaries store mappings from keys to values
empty_dict = {}
# Here is a prefilled dictionary
filled_dict = {&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3}

# Note keys for dictionaries have to be immutable types. This is to ensure that
# the key can be converted to a constant hash value for quick look-ups.
# Immutable types include ints, floats, strings, tuples.
invalid_dict = {[1,2,3]: &quot;123&quot;}  # =&gt; Yield a TypeError: unhashable type: 'list'
valid_dict = {(1,2,3):[1,2,3]}   # Values can be of any type, however.

# Look up values with []
filled_dict[&quot;one&quot;]  # =&gt; 1

# Get all keys as an iterable with &quot;keys()&quot;. We need to wrap the call in list()
# to turn it into a list. We'll talk about those later.  Note - for Python
# versions &lt;3.7, dictionary key ordering is not guaranteed. Your results might
# not match the example below exactly. However, as of Python 3.7, dictionary
# items maintain the order at which they are inserted into the dictionary.
list(filled_dict.keys())  # =&gt; [&quot;three&quot;, &quot;two&quot;, &quot;one&quot;] in Python &lt;3.7
list(filled_dict.keys())  # =&gt; [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;] in Python 3.7+


# Get all values as an iterable with &quot;values()&quot;. Once again we need to wrap it
# in list() to get it out of the iterable. Note - Same as above regarding key
# ordering.
list(filled_dict.values())  # =&gt; [3, 2, 1]  in Python &lt;3.7
list(filled_dict.values())  # =&gt; [1, 2, 3] in Python 3.7+

# Check for existence of keys in a dictionary with &quot;in&quot;
&quot;one&quot; in filled_dict  # =&gt; True
1 in filled_dict      # =&gt; False

# Looking up a non-existing key is a KeyError
filled_dict[&quot;four&quot;]  # KeyError

# Use &quot;get()&quot; method to avoid the KeyError
filled_dict.get(&quot;one&quot;)      # =&gt; 1
filled_dict.get(&quot;four&quot;)     # =&gt; None
# The get method supports a default argument when the value is missing
filled_dict.get(&quot;one&quot;, 4)   # =&gt; 1
filled_dict.get(&quot;four&quot;, 4)  # =&gt; 4

# &quot;setdefault()&quot; inserts into a dictionary only if the given key isn't present
filled_dict.setdefault(&quot;five&quot;, 5)  # filled_dict[&quot;five&quot;] is set to 5
filled_dict.setdefault(&quot;five&quot;, 6)  # filled_dict[&quot;five&quot;] is still 5

# Adding to a dictionary
filled_dict.update({&quot;four&quot;:4})  # =&gt; {&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3, &quot;four&quot;: 4}
filled_dict[&quot;four&quot;] = 4         # another way to add to dict

# Remove keys from a dictionary with del
del filled_dict[&quot;one&quot;]  # Removes the key &quot;one&quot; from filled dict

# From Python 3.5 you can also use the additional unpacking options
{'a': 1, **{'b': 2}}  # =&gt; {'a': 1, 'b': 2}
{'a': 1, **{'a': 2}}  # =&gt; {'a': 2}



# Sets store ... well sets
empty_set = set()
# Initialize a set with a bunch of values.
some_set = {1, 1, 2, 2, 3, 4}  # some_set is now {1, 2, 3, 4}

# Similar to keys of a dictionary, elements of a set have to be immutable.
invalid_set = {[1], 1}  # =&gt; Raises a TypeError: unhashable type: 'list'
valid_set = {(1,), 1}

# Add one more item to the set
filled_set = some_set
filled_set.add(5)  # filled_set is now {1, 2, 3, 4, 5}
# Sets do not have duplicate elements
filled_set.add(5)  # it remains as before {1, 2, 3, 4, 5}

# Do set intersection with &amp;
other_set = {3, 4, 5, 6}
filled_set &amp; other_set  # =&gt; {3, 4, 5}

# Do set union with |
filled_set | other_set  # =&gt; {1, 2, 3, 4, 5, 6}

# Do set difference with -
{1, 2, 3, 4} - {2, 3, 5}  # =&gt; {1, 4}

# Do set symmetric difference with ^
{1, 2, 3, 4} ^ {2, 3, 5}  # =&gt; {1, 4, 5}

# Check if set on the left is a superset of set on the right
{1, 2} &gt;= {1, 2, 3} # =&gt; False

# Check if set on the left is a subset of set on the right
{1, 2} &lt;= {1, 2, 3} # =&gt; True

# Check for existence in a set with in
2 in filled_set   # =&gt; True
10 in filled_set  # =&gt; False

# Make a one layer deep copy
filled_set = some_set.copy()  # filled_set is {1, 2, 3, 4, 5}
filled_set is some_set        # =&gt; False


####################################################
## 3. Control Flow and Iterables
####################################################

# Let's just make a variable
some_var = 5

# Here is an if statement. Indentation is significant in Python!
# Convention is to use four spaces, not tabs.
# This prints &quot;some_var is smaller than 10&quot;
if some_var &gt; 10:
    print(&quot;some_var is totally bigger than 10.&quot;)
elif some_var &lt; 10:    # This elif clause is optional.
    print(&quot;some_var is smaller than 10.&quot;)
else:                  # This is optional too.
    print(&quot;some_var is indeed 10.&quot;)


&quot;&quot;&quot;
For loops iterate over lists
prints:
    dog is a mammal
    cat is a mammal
    mouse is a mammal
&quot;&quot;&quot;
for animal in [&quot;dog&quot;, &quot;cat&quot;, &quot;mouse&quot;]:
    # You can use format() to interpolate formatted strings
    print(&quot;{} is a mammal&quot;.format(animal))

&quot;&quot;&quot;
&quot;range(number)&quot; returns an iterable of numbers
from zero up to (but excluding) the given number
prints:
    0
    1
    2
    3
&quot;&quot;&quot;
for i in range(4):
    print(i)

&quot;&quot;&quot;
&quot;range(lower, upper)&quot; returns an iterable of numbers
from the lower number to the upper number
prints:
    4
    5
    6
    7
&quot;&quot;&quot;
for i in range(4, 8):
    print(i)

&quot;&quot;&quot;
&quot;range(lower, upper, step)&quot; returns an iterable of numbers
from the lower number to the upper number, while incrementing
by step. If step is not indicated, the default value is 1.
prints:
    4
    6
&quot;&quot;&quot;
for i in range(4, 8, 2):
    print(i)

&quot;&quot;&quot;
Loop over a list to retrieve both the index and the value of each list item:
    0 dog
    1 cat
    2 mouse
&quot;&quot;&quot;
animals = [&quot;dog&quot;, &quot;cat&quot;, &quot;mouse&quot;]
for i, value in enumerate(animals):
    print(i, value)

&quot;&quot;&quot;
While loops go until a condition is no longer met.
prints:
    0
    1
    2
    3
&quot;&quot;&quot;
x = 0
while x &lt; 4:
    print(x)
    x += 1  # Shorthand for x = x + 1

# Handle exceptions with a try/except block
try:
    # Use &quot;raise&quot; to raise an error
    raise IndexError(&quot;This is an index error&quot;)
except IndexError as e:
    pass                 # Refrain from this, provide a recovery (next example).
except (TypeError, NameError):
    pass                 # Multiple exceptions can be processed jointly.
else:                    # Optional clause to the try/except block. Must follow
                         # all except blocks.
    print(&quot;All good!&quot;)   # Runs only if the code in try raises no exceptions
finally:                 # Execute under all circumstances
    print(&quot;We can clean up resources here&quot;)

# Instead of try/finally to cleanup resources you can use a with statement
with open(&quot;myfile.txt&quot;) as f:
    for line in f:
        print(line)

# Writing to a file
contents = {&quot;aa&quot;: 12, &quot;bb&quot;: 21}
with open(&quot;myfile1.txt&quot;, &quot;w+&quot;) as file:
    file.write(str(contents))        # writes a string to a file

import json
with open(&quot;myfile2.txt&quot;, &quot;w+&quot;) as file:
    file.write(json.dumps(contents)) # writes an object to a file

# Reading from a file
with open('myfile1.txt', &quot;r+&quot;) as file:
    contents = file.read()           # reads a string from a file
print(contents)
# print: {&quot;aa&quot;: 12, &quot;bb&quot;: 21}

with open('myfile2.txt', &quot;r+&quot;) as file:
    contents = json.load(file)       # reads a json object from a file
print(contents)
# print: {&quot;aa&quot;: 12, &quot;bb&quot;: 21}


# Python offers a fundamental abstraction called the Iterable.
# An iterable is an object that can be treated as a sequence.
# The object returned by the range function, is an iterable.

filled_dict = {&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3}
our_iterable = filled_dict.keys()
print(our_iterable)  # =&gt; dict_keys(['one', 'two', 'three']). This is an object
                     # that implements our Iterable interface.

# We can loop over it.
for i in our_iterable:
    print(i)  # Prints one, two, three

# However we cannot address elements by index.
our_iterable[1]  # Raises a TypeError

# An iterable is an object that knows how to create an iterator.
our_iterator = iter(our_iterable)

# Our iterator is an object that can remember the state as we traverse through
# it. We get the next object with &quot;next()&quot;.
next(our_iterator)  # =&gt; &quot;one&quot;

# It maintains state as we iterate.
next(our_iterator)  # =&gt; &quot;two&quot;
next(our_iterator)  # =&gt; &quot;three&quot;

# After the iterator has returned all of its data, it raises a
# StopIteration exception
next(our_iterator)  # Raises StopIteration

# We can also loop over it, in fact, &quot;for&quot; does this implicitly!
our_iterator = iter(our_iterable)
for i in our_iterator:
    print(i)  # Prints one, two, three

# You can grab all the elements of an iterable or iterator by call of list().
list(our_iterable)  # =&gt; Returns [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]
list(our_iterator)  # =&gt; Returns [] because state is saved


####################################################
## 4. Functions
####################################################

# Use &quot;def&quot; to create new functions
def add(x, y):
    print(&quot;x is {} and y is {}&quot;.format(x, y))
    return x + y  # Return values with a return statement

# Calling functions with parameters
add(5, 6)  # =&gt; prints out &quot;x is 5 and y is 6&quot; and returns 11

# Another way to call functions is with keyword arguments
add(y=6, x=5)  # Keyword arguments can arrive in any order.

# You can define functions that take a variable number of
# positional arguments
def varargs(*args):
    return args

varargs(1, 2, 3)  # =&gt; (1, 2, 3)

# You can define functions that take a variable number of
# keyword arguments, as well
def keyword_args(**kwargs):
    return kwargs

# Let's call it to see what happens
keyword_args(big=&quot;foot&quot;, loch=&quot;ness&quot;)  # =&gt; {&quot;big&quot;: &quot;foot&quot;, &quot;loch&quot;: &quot;ness&quot;}


# You can do both at once, if you like
def all_the_args(*args, **kwargs):
    print(args)
    print(kwargs)
&quot;&quot;&quot;
all_the_args(1, 2, a=3, b=4) prints:
    (1, 2)
    {&quot;a&quot;: 3, &quot;b&quot;: 4}
&quot;&quot;&quot;

# When calling functions, you can do the opposite of args/kwargs!
# Use * to expand tuples and use ** to expand kwargs.
args = (1, 2, 3, 4)
kwargs = {&quot;a&quot;: 3, &quot;b&quot;: 4}
all_the_args(*args)            # equivalent: all_the_args(1, 2, 3, 4)
all_the_args(**kwargs)         # equivalent: all_the_args(a=3, b=4)
all_the_args(*args, **kwargs)  # equivalent: all_the_args(1, 2, 3, 4, a=3, b=4)

# Returning multiple values (with tuple assignments)
def swap(x, y):
    return y, x  # Return multiple values as a tuple without the parenthesis.
                 # (Note: parenthesis have been excluded but can be included)

x = 1
y = 2
x, y = swap(x, y)     # =&gt; x = 2, y = 1
# (x, y) = swap(x,y)  # Again the use of parenthesis is optional.

# global scope
x = 5

def set_x(num):
    # local scope begins here
    # local var x not the same as global var x
    x = num    # =&gt; 43
    print(x)   # =&gt; 43

def set_global_x(num):
    # global indicates that particular var lives in the global scope
    global x
    print(x)   # =&gt; 5
    x = num    # global var x is now set to 6
    print(x)   # =&gt; 6

set_x(43)
set_global_x(6)
&quot;&quot;&quot;
prints:
    43
    5
    6
&quot;&quot;&quot;


# Python has first class functions
def create_adder(x):
    def adder(y):
        return x + y
    return adder

add_10 = create_adder(10)
add_10(3)   # =&gt; 13

# There are also anonymous functions
(lambda x: x &gt; 2)(3)                  # =&gt; True
(lambda x, y: x ** 2 + y ** 2)(2, 1)  # =&gt; 5

# There are built-in higher order functions
list(map(add_10, [1, 2, 3]))          # =&gt; [11, 12, 13]
list(map(max, [1, 2, 3], [4, 2, 1]))  # =&gt; [4, 2, 3]

list(filter(lambda x: x &gt; 5, [3, 4, 5, 6, 7]))  # =&gt; [6, 7]

# We can use list comprehensions for nice maps and filters
# List comprehension stores the output as a list (which itself may be nested).
[add_10(i) for i in [1, 2, 3]]         # =&gt; [11, 12, 13]
[x for x in [3, 4, 5, 6, 7] if x &gt; 5]  # =&gt; [6, 7]

# You can construct set and dict comprehensions as well.
{x for x in 'abcddeef' if x not in 'abc'}  # =&gt; {'d', 'e', 'f'}
{x: x**2 for x in range(5)}  # =&gt; {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}


####################################################
## 5. Modules
####################################################

# You can import modules
import math
print(math.sqrt(16))  # =&gt; 4.0

# You can get specific functions from a module
from math import ceil, floor
print(ceil(3.7))   # =&gt; 4.0
print(floor(3.7))  # =&gt; 3.0

# You can import all functions from a module.
# Warning: this is not recommended
from math import *

# You can shorten module names
import math as m
math.sqrt(16) == m.sqrt(16)  # =&gt; True

# Python modules are just ordinary Python files. You
# can write your own, and import them. The name of the
# module is the same as the name of the file.

# You can find out which functions and attributes
# are defined in a module.
import math
dir(math)

# If you have a Python script named math.py in the same
# folder as your current script, the file math.py will
# be loaded instead of the built-in Python module.
# This happens because the local folder has priority
# over Python's built-in libraries.


####################################################
## 6. Classes
####################################################

# We use the &quot;class&quot; statement to create a class
class Human:

    # A class attribute. It is shared by all instances of this class
    species = &quot;H. sapiens&quot;

    # Basic initializer, this is called when this class is instantiated.
    # Note that the double leading and trailing underscores denote objects
    # or attributes that are used by Python but that live in user-controlled
    # namespaces. Methods(or objects or attributes) like: __init__, __str__,
    # __repr__ etc. are called special methods (or sometimes called dunder
    # methods). You should not invent such names on your own.
    def __init__(self, name):
        # Assign the argument to the instance's name attribute
        self.name = name

        # Initialize property
        self._age = 0

    # An instance method. All methods take &quot;self&quot; as the first argument
    def say(self, msg):
        print(&quot;{name}: {message}&quot;.format(name=self.name, message=msg))

    # Another instance method
    def sing(self):
        return 'yo... yo... microphone check... one two... one two...'

    # A class method is shared among all instances
    # They are called with the calling class as the first argument
    @classmethod
    def get_species(cls):
        return cls.species

    # A static method is called without a class or instance reference
    @staticmethod
    def grunt():
        return &quot;*grunt*&quot;

    # A property is just like a getter.
    # It turns the method age() into a read-only attribute of the same name.
    # There's no need to write trivial getters and setters in Python, though.
    @property
    def age(self):
        return self._age

    # This allows the property to be set
    @age.setter
    def age(self, age):
        self._age = age

    # This allows the property to be deleted
    @age.deleter
    def age(self):
        del self._age


# When a Python interpreter reads a source file it executes all its code.
# This __name__ check makes sure this code block is only executed when this
# module is the main program.
if __name__ == '__main__':
    # Instantiate a class
    i = Human(name=&quot;Ian&quot;)
    i.say(&quot;hi&quot;)                     # &quot;Ian: hi&quot;
    j = Human(&quot;Joel&quot;)
    j.say(&quot;hello&quot;)                  # &quot;Joel: hello&quot;
    # i and j are instances of type Human; i.e., they are Human objects.

    # Call our class method
    i.say(i.get_species())          # &quot;Ian: H. sapiens&quot;
    # Change the shared attribute
    Human.species = &quot;H. neanderthalensis&quot;
    i.say(i.get_species())          # =&gt; &quot;Ian: H. neanderthalensis&quot;
    j.say(j.get_species())          # =&gt; &quot;Joel: H. neanderthalensis&quot;

    # Call the static method
    print(Human.grunt())            # =&gt; &quot;*grunt*&quot;

    # Static methods can be called by instances too
    print(i.grunt())                # =&gt; &quot;*grunt*&quot;

    # Update the property for this instance
    i.age = 42
    # Get the property
    i.say(i.age)                    # =&gt; &quot;Ian: 42&quot;
    j.say(j.age)                    # =&gt; &quot;Joel: 0&quot;
    # Delete the property
    del i.age
    # i.age                         # =&gt; this would raise an AttributeError


####################################################
## 6.1 Inheritance
####################################################

# Inheritance allows new child classes to be defined that inherit methods and
# variables from their parent class.

# Using the Human class defined above as the base or parent class, we can
# define a child class, Superhero, which inherits the class variables like
# &quot;species&quot;, &quot;name&quot;, and &quot;age&quot;, as well as methods, like &quot;sing&quot; and &quot;grunt&quot;
# from the Human class, but can also have its own unique properties.

# To take advantage of modularization by file you could place the classes above
# in their own files, say, human.py

# To import functions from other files use the following format
# from &quot;filename-without-extension&quot; import &quot;function-or-class&quot;

from human import Human


# Specify the parent class(es) as parameters to the class definition
class Superhero(Human):

    # If the child class should inherit all of the parent's definitions without
    # any modifications, you can just use the &quot;pass&quot; keyword (and nothing else)
    # but in this case it is commented out to allow for a unique child class:
    # pass

    # Child classes can override their parents' attributes
    species = 'Superhuman'

    # Children automatically inherit their parent class's constructor including
    # its arguments, but can also define additional arguments or definitions
    # and override its methods such as the class constructor.
    # This constructor inherits the &quot;name&quot; argument from the &quot;Human&quot; class and
    # adds the &quot;superpower&quot; and &quot;movie&quot; arguments:
    def __init__(self, name, movie=False,
                 superpowers=[&quot;super strength&quot;, &quot;bulletproofing&quot;]):

        # add additional class attributes:
        self.fictional = True
        self.movie = movie
        # be aware of mutable default values, since defaults are shared
        self.superpowers = superpowers

        # The &quot;super&quot; function lets you access the parent class's methods
        # that are overridden by the child, in this case, the __init__ method.
        # This calls the parent class constructor:
        super().__init__(name)

    # override the sing method
    def sing(self):
        return 'Dun, dun, DUN!'

    # add an additional instance method
    def boast(self):
        for power in self.superpowers:
            print(&quot;I wield the power of {pow}!&quot;.format(pow=power))


if __name__ == '__main__':
    sup = Superhero(name=&quot;Tick&quot;)

    # Instance type checks
    if isinstance(sup, Human):
        print('I am human')
    if type(sup) is Superhero:
        print('I am a superhero')

    # Get the Method Resolution search Order used by both getattr() and super()
    # This attribute is dynamic and can be updated
    print(Superhero.__mro__)    # =&gt; (&lt;class '__main__.Superhero'&gt;,
                                # =&gt; &lt;class 'human.Human'&gt;, &lt;class 'object'&gt;)

    # Calls parent method but uses its own class attribute
    print(sup.get_species())    # =&gt; Superhuman

    # Calls overridden method
    print(sup.sing())           # =&gt; Dun, dun, DUN!

    # Calls method from Human
    sup.say('Spoon')            # =&gt; Tick: Spoon

    # Call method that exists only in Superhero
    sup.boast()                 # =&gt; I wield the power of super strength!
                                # =&gt; I wield the power of bulletproofing!

    # Inherited class attribute
    sup.age = 31
    print(sup.age)              # =&gt; 31

    # Attribute that only exists within Superhero
    print('Am I Oscar eligible? ' + str(sup.movie))

####################################################
## 6.2 Multiple Inheritance
####################################################

# Another class definition
# bat.py
class Bat:

    species = 'Baty'

    def __init__(self, can_fly=True):
        self.fly = can_fly

    # This class also has a say method
    def say(self, msg):
        msg = '... ... ...'
        return msg

    # And its own method as well
    def sonar(self):
        return '))) ... ((('

if __name__ == '__main__':
    b = Bat()
    print(b.say('hello'))
    print(b.fly)


# And yet another class definition that inherits from Superhero and Bat
# superhero.py
from superhero import Superhero
from bat import Bat

# Define Batman as a child that inherits from both Superhero and Bat
class Batman(Superhero, Bat):

    def __init__(self, *args, **kwargs):
        # Typically to inherit attributes you have to call super:
        # super(Batman, self).__init__(*args, **kwargs)
        # However we are dealing with multiple inheritance here, and super()
        # only works with the next base class in the MRO list.
        # So instead we explicitly call __init__ for all ancestors.
        # The use of *args and **kwargs allows for a clean way to pass
        # arguments, with each parent &quot;peeling a layer of the onion&quot;.
        Superhero.__init__(self, 'anonymous', movie=True,
                           superpowers=['Wealthy'], *args, **kwargs)
        Bat.__init__(self, *args, can_fly=False, **kwargs)
        # override the value for the name attribute
        self.name = 'Sad Affleck'

    def sing(self):
        return 'nan nan nan nan nan batman!'


if __name__ == '__main__':
    sup = Batman()

    # Get the Method Resolution search Order used by both getattr() and super().
    # This attribute is dynamic and can be updated
    print(Batman.__mro__)       # =&gt; (&lt;class '__main__.Batman'&gt;,
                                # =&gt; &lt;class 'superhero.Superhero'&gt;,
                                # =&gt; &lt;class 'human.Human'&gt;,
                                # =&gt; &lt;class 'bat.Bat'&gt;, &lt;class 'object'&gt;)

    # Calls parent method but uses its own class attribute
    print(sup.get_species())    # =&gt; Superhuman

    # Calls overridden method
    print(sup.sing())           # =&gt; nan nan nan nan nan batman!

    # Calls method from Human, because inheritance order matters
    sup.say('I agree')          # =&gt; Sad Affleck: I agree

    # Call method that exists only in 2nd ancestor
    print(sup.sonar())          # =&gt; ))) ... (((

    # Inherited class attribute
    sup.age = 100
    print(sup.age)              # =&gt; 100

    # Inherited attribute from 2nd ancestor whose default value was overridden.
    print('Can I fly? ' + str(sup.fly)) # =&gt; Can I fly? False



####################################################
## 7. Advanced
####################################################

# Generators help you make lazy code.
def double_numbers(iterable):
    for i in iterable:
        yield i + i

# Generators are memory-efficient because they only load the data needed to
# process the next value in the iterable. This allows them to perform
# operations on otherwise prohibitively large value ranges.
# NOTE: `range` replaces `xrange` in Python 3.
for i in double_numbers(range(1, 900000000)):  # `range` is a generator.
    print(i)
    if i &gt;= 30:
        break

# Just as you can create a list comprehension, you can create generator
# comprehensions as well.
values = (-x for x in [1,2,3,4,5])
for x in values:
    print(x)  # prints -1 -2 -3 -4 -5 to console/terminal

# You can also cast a generator comprehension directly to a list.
values = (-x for x in [1,2,3,4,5])
gen_to_list = list(values)
print(gen_to_list)  # =&gt; [-1, -2, -3, -4, -5]


# Decorators
# In this example `beg` wraps `say`. If say_please is True then it
# will change the returned message.
from functools import wraps


def intro(target_function):
    @wraps(target_function)
    def wrapper(*args, **kwargs):
        msg, say_please = target_function(*args, **kwargs)
        if say_please:
            return &quot;{} {}&quot;.format(msg, &quot;My name is Nitkarsh Chourasia.&quot;)
        return msg

    return wrapper


@intro
def say(say_please=False):
    msg = &quot;I published this static site, here.&quot;
    return msg, say_please


print(say())                 # I published this static site, here.
print(say(say_please=True))  # I published this static site, here. My name is Nitkarsh Chourasia.






####################################################
## Author's Info
####################################################

import webbrowser

class Author:
    def __init__(self, name: str, github_profile_url: str) -&gt; None:
        &quot;&quot;&quot;Initialize the Author class with name and GitHub profile URL.&quot;&quot;&quot;
        self.name = name
        self.github_profile_url = github_profile_url
        self.github_username = github_profile_url[19:]

    def open_github_profile(self) -&gt; None:
        &quot;&quot;&quot;Open the author's GitHub profile in a new tab.&quot;&quot;&quot;
        return webbrowser.open_new_tab(self.github_profile_url)

# Create an instance of the Author class
AUTHOR = Author(&quot;Nitkarsh Chourasia&quot;, &quot;https://github.com/NitkarshChourasia&quot;)

# Access the encapsulated data
print(f&quot;Author Name: {AUTHOR.name}&quot;)
print(f&quot;Github Profile Link: {AUTHOR.github_profile_url}&quot;)
print(f&quot;Github Username: {AUTHOR.github_username}&quot;)

# Open the author's GitHub profile in a new tab
AUTHOR.open_github_profile()

####################################################

</code></pre>
                </p>
            </article>
        </section>
        <!-- endblock -->

        <!-- block footer -->
        <footer>
            <div class="d-flex flex-sm-row justify-content-between py-2 border-top drac-text-black drac-bg-cyan-green">
                <a href="https://github.com/NitkarshChourasia" target="_blank" style="padding-left: 1%;"
                    class="footer-text drac-anchor drac-text-black drac-text-purple--hover">
                    Made with ❤️ by Nitkarsh Chourasia
                </a>
            </div>
        </footer>
        <!-- endblock -->
        </div>

    </main>

    <script>var base_url = '.';</script>
    <script src="assets/js/jquery-3.3.1.slim.min.js""></script>
        <script src=" assets/js/bootstrap.bundle.min.js""></script>
    <script src="assets/js/mkdocs.js""></script>
			<script src=" search/main.js" defer></script>

</body>

</html>